schema {
  query: Query
  subscription: Subscription
}

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

type Account {
  clusters(first: Int = 100, orderBy: Cluster_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Cluster_filter): [Cluster!]
  feeRecipient: Bytes!
  id: Bytes!
  nonce: BigInt!
  operators(first: Int = 100, orderBy: Operator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Operator_filter): [Operator!]
  validatorCount: BigInt!
  validators(first: Int = 100, orderBy: Validator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Validator_filter): [Validator!]
}

input Account_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  clusters_: Cluster_filter
  feeRecipient: Bytes
  feeRecipient_contains: Bytes
  feeRecipient_gt: Bytes
  feeRecipient_gte: Bytes
  feeRecipient_in: [Bytes!]
  feeRecipient_lt: Bytes
  feeRecipient_lte: Bytes
  feeRecipient_not: Bytes
  feeRecipient_not_contains: Bytes
  feeRecipient_not_in: [Bytes!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  nonce: BigInt
  nonce_gt: BigInt
  nonce_gte: BigInt
  nonce_in: [BigInt!]
  nonce_lt: BigInt
  nonce_lte: BigInt
  nonce_not: BigInt
  nonce_not_in: [BigInt!]
  operators_: Operator_filter
  or: [Account_filter]
  validatorCount: BigInt
  validatorCount_gt: BigInt
  validatorCount_gte: BigInt
  validatorCount_in: [BigInt!]
  validatorCount_lt: BigInt
  validatorCount_lte: BigInt
  validatorCount_not: BigInt
  validatorCount_not_in: [BigInt!]
  validators_: Validator_filter
}

enum Account_orderBy {
  clusters
  feeRecipient
  id
  nonce
  operators
  validatorCount
  validators
}

enum Aggregation_interval {
  day
  hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Cluster {
  active: Boolean!
  balance: BigInt!
  id: String!
  index: BigInt!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  networkFeeIndex: BigInt!
  operatorIds: [BigInt!]!
  owner: Account!
  validatorCount: BigInt!
  validators(first: Int = 100, orderBy: Validator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Validator_filter): [Validator!]
}

type ClusterDeposited {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input ClusterDeposited_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterDeposited_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterDeposited_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum ClusterDeposited_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
  value
}

type ClusterLiquidated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
}

input ClusterLiquidated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterLiquidated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterLiquidated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ClusterLiquidated_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
}

type ClusterReactivated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
}

input ClusterReactivated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterReactivated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterReactivated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ClusterReactivated_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
}

type ClusterWithdrawn {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input ClusterWithdrawn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ClusterWithdrawn_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ClusterWithdrawn_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum ClusterWithdrawn_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  transactionHash
  value
}

input Cluster_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  and: [Cluster_filter]
  balance: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_in: [BigInt!]
  balance_lt: BigInt
  balance_lte: BigInt
  balance_not: BigInt
  balance_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  index: BigInt
  index_gt: BigInt
  index_gte: BigInt
  index_in: [BigInt!]
  index_lt: BigInt
  index_lte: BigInt
  index_not: BigInt
  index_not_in: [BigInt!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  networkFeeIndex: BigInt
  networkFeeIndex_gt: BigInt
  networkFeeIndex_gte: BigInt
  networkFeeIndex_in: [BigInt!]
  networkFeeIndex_lt: BigInt
  networkFeeIndex_lte: BigInt
  networkFeeIndex_not: BigInt
  networkFeeIndex_not_in: [BigInt!]
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [Cluster_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  validatorCount: BigInt
  validatorCount_gt: BigInt
  validatorCount_gte: BigInt
  validatorCount_in: [BigInt!]
  validatorCount_lt: BigInt
  validatorCount_lte: BigInt
  validatorCount_not: BigInt
  validatorCount_not_in: [BigInt!]
  validators_: Validator_filter
}

enum Cluster_orderBy {
  active
  balance
  id
  index
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  networkFeeIndex
  operatorIds
  owner
  owner__feeRecipient
  owner__id
  owner__nonce
  owner__validatorCount
  validatorCount
  validators
}

enum DAOUpdateTypes {
  DECLARE_OPERATOR_FEE_PERIOD
  EXECUTE_OPERATOR_FEE_PERIOD
  INITIALIZATION
  LIQUIDATION_THRESHOLD
  MIN_LIQUIDATION_COLLATERAL
  NETWORK_FEE
  OPERATOR_ADDED
  OPERATOR_FEE_INCREASE_LIMIT
  OPERATOR_MAX_FEE
  OPERATOR_REMOVED
  VALIDATOR_ADDED
  VALIDATOR_REMOVED
}

type DAOValues {
  declareOperatorFeePeriod: BigInt!
  executeOperatorFeePeriod: BigInt!
  id: Bytes!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  liquidationThreshold: BigInt!
  minimumLiquidationCollateral: BigInt!
  networkFee: BigInt!
  networkFeeIndex: BigInt!
  networkFeeIndexBlockNumber: BigInt!
  operatorFeeIncreaseLimit: BigInt!
  operatorMaximumFee: BigInt!
  operatorsAdded: BigInt!
  operatorsRemoved: BigInt!
  totalAccounts: BigInt!
  totalOperators: BigInt!
  totalValidators: BigInt!
  updateType: DAOUpdateTypes!
  validatorsAdded: BigInt!
  validatorsPerOperatorLimit: BigInt!
  validatorsRemoved: BigInt!
}

input DAOValues_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAOValues_filter]
  declareOperatorFeePeriod: BigInt
  declareOperatorFeePeriod_gt: BigInt
  declareOperatorFeePeriod_gte: BigInt
  declareOperatorFeePeriod_in: [BigInt!]
  declareOperatorFeePeriod_lt: BigInt
  declareOperatorFeePeriod_lte: BigInt
  declareOperatorFeePeriod_not: BigInt
  declareOperatorFeePeriod_not_in: [BigInt!]
  executeOperatorFeePeriod: BigInt
  executeOperatorFeePeriod_gt: BigInt
  executeOperatorFeePeriod_gte: BigInt
  executeOperatorFeePeriod_in: [BigInt!]
  executeOperatorFeePeriod_lt: BigInt
  executeOperatorFeePeriod_lte: BigInt
  executeOperatorFeePeriod_not: BigInt
  executeOperatorFeePeriod_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  liquidationThreshold: BigInt
  liquidationThreshold_gt: BigInt
  liquidationThreshold_gte: BigInt
  liquidationThreshold_in: [BigInt!]
  liquidationThreshold_lt: BigInt
  liquidationThreshold_lte: BigInt
  liquidationThreshold_not: BigInt
  liquidationThreshold_not_in: [BigInt!]
  minimumLiquidationCollateral: BigInt
  minimumLiquidationCollateral_gt: BigInt
  minimumLiquidationCollateral_gte: BigInt
  minimumLiquidationCollateral_in: [BigInt!]
  minimumLiquidationCollateral_lt: BigInt
  minimumLiquidationCollateral_lte: BigInt
  minimumLiquidationCollateral_not: BigInt
  minimumLiquidationCollateral_not_in: [BigInt!]
  networkFee: BigInt
  networkFeeIndex: BigInt
  networkFeeIndexBlockNumber: BigInt
  networkFeeIndexBlockNumber_gt: BigInt
  networkFeeIndexBlockNumber_gte: BigInt
  networkFeeIndexBlockNumber_in: [BigInt!]
  networkFeeIndexBlockNumber_lt: BigInt
  networkFeeIndexBlockNumber_lte: BigInt
  networkFeeIndexBlockNumber_not: BigInt
  networkFeeIndexBlockNumber_not_in: [BigInt!]
  networkFeeIndex_gt: BigInt
  networkFeeIndex_gte: BigInt
  networkFeeIndex_in: [BigInt!]
  networkFeeIndex_lt: BigInt
  networkFeeIndex_lte: BigInt
  networkFeeIndex_not: BigInt
  networkFeeIndex_not_in: [BigInt!]
  networkFee_gt: BigInt
  networkFee_gte: BigInt
  networkFee_in: [BigInt!]
  networkFee_lt: BigInt
  networkFee_lte: BigInt
  networkFee_not: BigInt
  networkFee_not_in: [BigInt!]
  operatorFeeIncreaseLimit: BigInt
  operatorFeeIncreaseLimit_gt: BigInt
  operatorFeeIncreaseLimit_gte: BigInt
  operatorFeeIncreaseLimit_in: [BigInt!]
  operatorFeeIncreaseLimit_lt: BigInt
  operatorFeeIncreaseLimit_lte: BigInt
  operatorFeeIncreaseLimit_not: BigInt
  operatorFeeIncreaseLimit_not_in: [BigInt!]
  operatorMaximumFee: BigInt
  operatorMaximumFee_gt: BigInt
  operatorMaximumFee_gte: BigInt
  operatorMaximumFee_in: [BigInt!]
  operatorMaximumFee_lt: BigInt
  operatorMaximumFee_lte: BigInt
  operatorMaximumFee_not: BigInt
  operatorMaximumFee_not_in: [BigInt!]
  operatorsAdded: BigInt
  operatorsAdded_gt: BigInt
  operatorsAdded_gte: BigInt
  operatorsAdded_in: [BigInt!]
  operatorsAdded_lt: BigInt
  operatorsAdded_lte: BigInt
  operatorsAdded_not: BigInt
  operatorsAdded_not_in: [BigInt!]
  operatorsRemoved: BigInt
  operatorsRemoved_gt: BigInt
  operatorsRemoved_gte: BigInt
  operatorsRemoved_in: [BigInt!]
  operatorsRemoved_lt: BigInt
  operatorsRemoved_lte: BigInt
  operatorsRemoved_not: BigInt
  operatorsRemoved_not_in: [BigInt!]
  or: [DAOValues_filter]
  totalAccounts: BigInt
  totalAccounts_gt: BigInt
  totalAccounts_gte: BigInt
  totalAccounts_in: [BigInt!]
  totalAccounts_lt: BigInt
  totalAccounts_lte: BigInt
  totalAccounts_not: BigInt
  totalAccounts_not_in: [BigInt!]
  totalOperators: BigInt
  totalOperators_gt: BigInt
  totalOperators_gte: BigInt
  totalOperators_in: [BigInt!]
  totalOperators_lt: BigInt
  totalOperators_lte: BigInt
  totalOperators_not: BigInt
  totalOperators_not_in: [BigInt!]
  totalValidators: BigInt
  totalValidators_gt: BigInt
  totalValidators_gte: BigInt
  totalValidators_in: [BigInt!]
  totalValidators_lt: BigInt
  totalValidators_lte: BigInt
  totalValidators_not: BigInt
  totalValidators_not_in: [BigInt!]
  updateType: DAOUpdateTypes
  updateType_in: [DAOUpdateTypes!]
  updateType_not: DAOUpdateTypes
  updateType_not_in: [DAOUpdateTypes!]
  validatorsAdded: BigInt
  validatorsAdded_gt: BigInt
  validatorsAdded_gte: BigInt
  validatorsAdded_in: [BigInt!]
  validatorsAdded_lt: BigInt
  validatorsAdded_lte: BigInt
  validatorsAdded_not: BigInt
  validatorsAdded_not_in: [BigInt!]
  validatorsPerOperatorLimit: BigInt
  validatorsPerOperatorLimit_gt: BigInt
  validatorsPerOperatorLimit_gte: BigInt
  validatorsPerOperatorLimit_in: [BigInt!]
  validatorsPerOperatorLimit_lt: BigInt
  validatorsPerOperatorLimit_lte: BigInt
  validatorsPerOperatorLimit_not: BigInt
  validatorsPerOperatorLimit_not_in: [BigInt!]
  validatorsRemoved: BigInt
  validatorsRemoved_gt: BigInt
  validatorsRemoved_gte: BigInt
  validatorsRemoved_in: [BigInt!]
  validatorsRemoved_lt: BigInt
  validatorsRemoved_lte: BigInt
  validatorsRemoved_not: BigInt
  validatorsRemoved_not_in: [BigInt!]
}

enum DAOValues_orderBy {
  declareOperatorFeePeriod
  executeOperatorFeePeriod
  id
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  liquidationThreshold
  minimumLiquidationCollateral
  networkFee
  networkFeeIndex
  networkFeeIndexBlockNumber
  operatorFeeIncreaseLimit
  operatorMaximumFee
  operatorsAdded
  operatorsRemoved
  totalAccounts
  totalOperators
  totalValidators
  updateType
  validatorsAdded
  validatorsPerOperatorLimit
  validatorsRemoved
}

type DeclareOperatorFeePeriodUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input DeclareOperatorFeePeriodUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DeclareOperatorFeePeriodUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [DeclareOperatorFeePeriodUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum DeclareOperatorFeePeriodUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type ExecuteOperatorFeePeriodUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input ExecuteOperatorFeePeriodUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ExecuteOperatorFeePeriodUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [ExecuteOperatorFeePeriodUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum ExecuteOperatorFeePeriodUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type FeeRecipientAddressUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  owner: Bytes!
  recipientAddress: Bytes!
  transactionHash: Bytes!
}

input FeeRecipientAddressUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FeeRecipientAddressUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [FeeRecipientAddressUpdated_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  recipientAddress: Bytes
  recipientAddress_contains: Bytes
  recipientAddress_gt: Bytes
  recipientAddress_gte: Bytes
  recipientAddress_in: [Bytes!]
  recipientAddress_lt: Bytes
  recipientAddress_lte: Bytes
  recipientAddress_not: Bytes
  recipientAddress_not_contains: Bytes
  recipientAddress_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum FeeRecipientAddressUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  owner
  recipientAddress
  transactionHash
}

"""
8 bytes signed integer

"""
scalar Int8

type LiquidationThresholdPeriodUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input LiquidationThresholdPeriodUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidationThresholdPeriodUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [LiquidationThresholdPeriodUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum LiquidationThresholdPeriodUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type MinimumLiquidationCollateralUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input MinimumLiquidationCollateralUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MinimumLiquidationCollateralUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [MinimumLiquidationCollateralUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum MinimumLiquidationCollateralUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type NetworkEarningsWithdrawn {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  recipient: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input NetworkEarningsWithdrawn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NetworkEarningsWithdrawn_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [NetworkEarningsWithdrawn_filter]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_gt: Bytes
  recipient_gte: Bytes
  recipient_in: [Bytes!]
  recipient_lt: Bytes
  recipient_lte: Bytes
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum NetworkEarningsWithdrawn_orderBy {
  blockNumber
  blockTimestamp
  id
  recipient
  transactionHash
  value
}

type NetworkFeeUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  newFee: BigInt!
  oldFee: BigInt!
  transactionHash: Bytes!
}

input NetworkFeeUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NetworkFeeUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  newFee: BigInt
  newFee_gt: BigInt
  newFee_gte: BigInt
  newFee_in: [BigInt!]
  newFee_lt: BigInt
  newFee_lte: BigInt
  newFee_not: BigInt
  newFee_not_in: [BigInt!]
  oldFee: BigInt
  oldFee_gt: BigInt
  oldFee_gte: BigInt
  oldFee_in: [BigInt!]
  oldFee_lt: BigInt
  oldFee_lte: BigInt
  oldFee_not: BigInt
  oldFee_not_in: [BigInt!]
  or: [NetworkFeeUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum NetworkFeeUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  newFee
  oldFee
  transactionHash
}

type Operator {
  declaredFee: BigInt!
  fee: BigInt!
  feeIndex: BigInt!
  feeIndexBlockNumber: BigInt!
  id: String!
  isPrivate: Boolean!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  operatorId: BigInt!
  owner: Account!
  publicKey: Bytes!
  removed: Boolean!
  totalWithdrawn: BigInt!
  validatorCount: BigInt!
  validators(first: Int = 100, orderBy: Validator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Validator_filter): [Validator!]
  whitelisted(first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Account_filter): [Account!]!
  whitelistedContract: Bytes!
}

type OperatorAdded {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  publicKey: Bytes!
  transactionHash: Bytes!
}

input OperatorAdded_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorAdded_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorAdded_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorAdded_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  operatorId
  owner
  publicKey
  transactionHash
}

type OperatorFeeDeclarationCancelled {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
}

input OperatorFeeDeclarationCancelled_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeDeclarationCancelled_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorFeeDeclarationCancelled_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorFeeDeclarationCancelled_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  owner
  transactionHash
}

type OperatorFeeDeclared {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
}

input OperatorFeeDeclared_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeDeclared_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorFeeDeclared_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorFeeDeclared_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  operatorId
  owner
  transactionHash
}

type OperatorFeeExecuted {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  fee: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
}

input OperatorFeeExecuted_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeExecuted_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  fee: BigInt
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorFeeExecuted_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorFeeExecuted_orderBy {
  blockNumber
  blockTimestamp
  fee
  id
  operatorId
  owner
  transactionHash
}

type OperatorFeeIncreaseLimitUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  transactionHash: Bytes!
  value: BigInt!
}

input OperatorFeeIncreaseLimitUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorFeeIncreaseLimitUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  or: [OperatorFeeIncreaseLimitUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum OperatorFeeIncreaseLimitUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  transactionHash
  value
}

type OperatorMaximumFeeUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  maxFee: BigInt!
  transactionHash: Bytes!
}

input OperatorMaximumFeeUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorMaximumFeeUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  maxFee: BigInt
  maxFee_gt: BigInt
  maxFee_gte: BigInt
  maxFee_in: [BigInt!]
  maxFee_lt: BigInt
  maxFee_lte: BigInt
  maxFee_not: BigInt
  maxFee_not_in: [BigInt!]
  or: [OperatorMaximumFeeUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorMaximumFeeUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  maxFee
  transactionHash
}

type OperatorMultipleWhitelistRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  transactionHash: Bytes!
  whitelistAddresses: [Bytes!]
}

input OperatorMultipleWhitelistRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorMultipleWhitelistRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorMultipleWhitelistRemoved_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelistAddresses: [Bytes!]
  whitelistAddresses_contains: [Bytes!]
  whitelistAddresses_contains_nocase: [Bytes!]
  whitelistAddresses_not: [Bytes!]
  whitelistAddresses_not_contains: [Bytes!]
  whitelistAddresses_not_contains_nocase: [Bytes!]
}

enum OperatorMultipleWhitelistRemoved_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  transactionHash
  whitelistAddresses
}

type OperatorMultipleWhitelistUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  transactionHash: Bytes!
  whitelistAddresses: [Bytes!]
}

input OperatorMultipleWhitelistUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorMultipleWhitelistUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorMultipleWhitelistUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelistAddresses: [Bytes!]
  whitelistAddresses_contains: [Bytes!]
  whitelistAddresses_contains_nocase: [Bytes!]
  whitelistAddresses_not: [Bytes!]
  whitelistAddresses_not_contains: [Bytes!]
  whitelistAddresses_not_contains_nocase: [Bytes!]
}

enum OperatorMultipleWhitelistUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  transactionHash
  whitelistAddresses
}

type OperatorPrivacyStatusUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  toPrivate: Boolean!
  transactionHash: Bytes!
}

input OperatorPrivacyStatusUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorPrivacyStatusUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorPrivacyStatusUpdated_filter]
  toPrivate: Boolean
  toPrivate_in: [Boolean!]
  toPrivate_not: Boolean
  toPrivate_not_in: [Boolean!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorPrivacyStatusUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  toPrivate
  transactionHash
}

type OperatorRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  transactionHash: Bytes!
}

input OperatorRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorRemoved_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum OperatorRemoved_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  transactionHash
}

type OperatorWhitelistUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  transactionHash: Bytes!
  whitelisted: Bytes!
}

input OperatorWhitelistUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorWhitelistUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorWhitelistUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelisted: Bytes
  whitelisted_contains: Bytes
  whitelisted_gt: Bytes
  whitelisted_gte: Bytes
  whitelisted_in: [Bytes!]
  whitelisted_lt: Bytes
  whitelisted_lte: Bytes
  whitelisted_not: Bytes
  whitelisted_not_contains: Bytes
  whitelisted_not_in: [Bytes!]
}

enum OperatorWhitelistUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  transactionHash
  whitelisted
}

type OperatorWhitelistingContractUpdated {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  transactionHash: Bytes!
  whitelistingContract: Bytes!
}

input OperatorWhitelistingContractUpdated_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorWhitelistingContractUpdated_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [OperatorWhitelistingContractUpdated_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  whitelistingContract: Bytes
  whitelistingContract_contains: Bytes
  whitelistingContract_gt: Bytes
  whitelistingContract_gte: Bytes
  whitelistingContract_in: [Bytes!]
  whitelistingContract_lt: Bytes
  whitelistingContract_lte: Bytes
  whitelistingContract_not: Bytes
  whitelistingContract_not_contains: Bytes
  whitelistingContract_not_in: [Bytes!]
}

enum OperatorWhitelistingContractUpdated_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorIds
  transactionHash
  whitelistingContract
}

type OperatorWithdrawn {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  id: String!
  operatorId: BigInt!
  owner: Bytes!
  transactionHash: Bytes!
  value: BigInt!
}

input OperatorWithdrawn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OperatorWithdrawn_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [OperatorWithdrawn_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  value: BigInt
  value_gt: BigInt
  value_gte: BigInt
  value_in: [BigInt!]
  value_lt: BigInt
  value_lte: BigInt
  value_not: BigInt
  value_not_in: [BigInt!]
}

enum OperatorWithdrawn_orderBy {
  blockNumber
  blockTimestamp
  id
  operatorId
  owner
  transactionHash
  value
}

input Operator_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Operator_filter]
  declaredFee: BigInt
  declaredFee_gt: BigInt
  declaredFee_gte: BigInt
  declaredFee_in: [BigInt!]
  declaredFee_lt: BigInt
  declaredFee_lte: BigInt
  declaredFee_not: BigInt
  declaredFee_not_in: [BigInt!]
  fee: BigInt
  feeIndex: BigInt
  feeIndexBlockNumber: BigInt
  feeIndexBlockNumber_gt: BigInt
  feeIndexBlockNumber_gte: BigInt
  feeIndexBlockNumber_in: [BigInt!]
  feeIndexBlockNumber_lt: BigInt
  feeIndexBlockNumber_lte: BigInt
  feeIndexBlockNumber_not: BigInt
  feeIndexBlockNumber_not_in: [BigInt!]
  feeIndex_gt: BigInt
  feeIndex_gte: BigInt
  feeIndex_in: [BigInt!]
  feeIndex_lt: BigInt
  feeIndex_lte: BigInt
  feeIndex_not: BigInt
  feeIndex_not_in: [BigInt!]
  fee_gt: BigInt
  fee_gte: BigInt
  fee_in: [BigInt!]
  fee_lt: BigInt
  fee_lte: BigInt
  fee_not: BigInt
  fee_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  isPrivate: Boolean
  isPrivate_in: [Boolean!]
  isPrivate_not: Boolean
  isPrivate_not_in: [Boolean!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  operatorId: BigInt
  operatorId_gt: BigInt
  operatorId_gte: BigInt
  operatorId_in: [BigInt!]
  operatorId_lt: BigInt
  operatorId_lte: BigInt
  operatorId_not: BigInt
  operatorId_not_in: [BigInt!]
  or: [Operator_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  removed: Boolean
  removed_in: [Boolean!]
  removed_not: Boolean
  removed_not_in: [Boolean!]
  totalWithdrawn: BigInt
  totalWithdrawn_gt: BigInt
  totalWithdrawn_gte: BigInt
  totalWithdrawn_in: [BigInt!]
  totalWithdrawn_lt: BigInt
  totalWithdrawn_lte: BigInt
  totalWithdrawn_not: BigInt
  totalWithdrawn_not_in: [BigInt!]
  validatorCount: BigInt
  validatorCount_gt: BigInt
  validatorCount_gte: BigInt
  validatorCount_in: [BigInt!]
  validatorCount_lt: BigInt
  validatorCount_lte: BigInt
  validatorCount_not: BigInt
  validatorCount_not_in: [BigInt!]
  validators_: Validator_filter
  whitelisted: [String!]
  whitelistedContract: Bytes
  whitelistedContract_contains: Bytes
  whitelistedContract_gt: Bytes
  whitelistedContract_gte: Bytes
  whitelistedContract_in: [Bytes!]
  whitelistedContract_lt: Bytes
  whitelistedContract_lte: Bytes
  whitelistedContract_not: Bytes
  whitelistedContract_not_contains: Bytes
  whitelistedContract_not_in: [Bytes!]
  whitelisted_: Account_filter
  whitelisted_contains: [String!]
  whitelisted_contains_nocase: [String!]
  whitelisted_not: [String!]
  whitelisted_not_contains: [String!]
  whitelisted_not_contains_nocase: [String!]
}

enum Operator_orderBy {
  declaredFee
  fee
  feeIndex
  feeIndexBlockNumber
  id
  isPrivate
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  operatorId
  owner
  owner__feeRecipient
  owner__id
  owner__nonce
  owner__validatorCount
  publicKey
  removed
  totalWithdrawn
  validatorCount
  validators
  whitelisted
  whitelistedContract
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  cluster(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Cluster
  clusterDeposited(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterDeposited
  clusterDepositeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterDeposited_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterDeposited_filter
  ): [ClusterDeposited!]!
  clusterLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterLiquidated
  clusterLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterLiquidated_filter
  ): [ClusterLiquidated!]!
  clusterReactivated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterReactivated
  clusterReactivateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterReactivated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterReactivated_filter
  ): [ClusterReactivated!]!
  clusterWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterWithdrawn
  clusterWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterWithdrawn_filter
  ): [ClusterWithdrawn!]!
  clusters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Cluster_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Cluster_filter
  ): [Cluster!]!
  daovalues(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOValues
  daovalues_collection(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DAOValues_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DAOValues_filter
  ): [DAOValues!]!
  declareOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DeclareOperatorFeePeriodUpdated
  declareOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DeclareOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DeclareOperatorFeePeriodUpdated_filter
  ): [DeclareOperatorFeePeriodUpdated!]!
  executeOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExecuteOperatorFeePeriodUpdated
  executeOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExecuteOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExecuteOperatorFeePeriodUpdated_filter
  ): [ExecuteOperatorFeePeriodUpdated!]!
  feeRecipientAddressUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeRecipientAddressUpdated
  feeRecipientAddressUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeRecipientAddressUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeRecipientAddressUpdated_filter
  ): [FeeRecipientAddressUpdated!]!
  liquidationThresholdPeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidationThresholdPeriodUpdated
  liquidationThresholdPeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidationThresholdPeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidationThresholdPeriodUpdated_filter
  ): [LiquidationThresholdPeriodUpdated!]!
  minimumLiquidationCollateralUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MinimumLiquidationCollateralUpdated
  minimumLiquidationCollateralUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MinimumLiquidationCollateralUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MinimumLiquidationCollateralUpdated_filter
  ): [MinimumLiquidationCollateralUpdated!]!
  networkEarningsWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkEarningsWithdrawn
  networkEarningsWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkEarningsWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkEarningsWithdrawn_filter
  ): [NetworkEarningsWithdrawn!]!
  networkFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkFeeUpdated
  networkFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkFeeUpdated_filter
  ): [NetworkFeeUpdated!]!
  operator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Operator
  operatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorAdded
  operatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorAdded_filter
  ): [OperatorAdded!]!
  operatorFeeDeclarationCancelled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclarationCancelled
  operatorFeeDeclarationCancelleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclarationCancelled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclarationCancelled_filter
  ): [OperatorFeeDeclarationCancelled!]!
  operatorFeeDeclared(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclared
  operatorFeeDeclareds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclared_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclared_filter
  ): [OperatorFeeDeclared!]!
  operatorFeeExecuted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeExecuted
  operatorFeeExecuteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeExecuted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeExecuted_filter
  ): [OperatorFeeExecuted!]!
  operatorFeeIncreaseLimitUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeIncreaseLimitUpdated
  operatorFeeIncreaseLimitUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeIncreaseLimitUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeIncreaseLimitUpdated_filter
  ): [OperatorFeeIncreaseLimitUpdated!]!
  operatorMaximumFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMaximumFeeUpdated
  operatorMaximumFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMaximumFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMaximumFeeUpdated_filter
  ): [OperatorMaximumFeeUpdated!]!
  operatorMultipleWhitelistRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistRemoved
  operatorMultipleWhitelistRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistRemoved_filter
  ): [OperatorMultipleWhitelistRemoved!]!
  operatorMultipleWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistUpdated
  operatorMultipleWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistUpdated_filter
  ): [OperatorMultipleWhitelistUpdated!]!
  operatorPrivacyStatusUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorPrivacyStatusUpdated
  operatorPrivacyStatusUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorPrivacyStatusUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorPrivacyStatusUpdated_filter
  ): [OperatorPrivacyStatusUpdated!]!
  operatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorRemoved
  operatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorRemoved_filter
  ): [OperatorRemoved!]!
  operatorWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistUpdated
  operatorWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistUpdated_filter
  ): [OperatorWhitelistUpdated!]!
  operatorWhitelistingContractUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistingContractUpdated
  operatorWhitelistingContractUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistingContractUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistingContractUpdated_filter
  ): [OperatorWhitelistingContractUpdated!]!
  operatorWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWithdrawn
  operatorWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWithdrawn_filter
  ): [OperatorWithdrawn!]!
  operators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Operator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Operator_filter
  ): [Operator!]!
  validator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Validator
  validatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorAdded
  validatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorAdded_filter
  ): [ValidatorAdded!]!
  validatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorRemoved
  validatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorRemoved_filter
  ): [ValidatorRemoved!]!
  validators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Validator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Validator_filter
  ): [Validator!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  cluster(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Cluster
  clusterDeposited(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterDeposited
  clusterDepositeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterDeposited_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterDeposited_filter
  ): [ClusterDeposited!]!
  clusterLiquidated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterLiquidated
  clusterLiquidateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterLiquidated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterLiquidated_filter
  ): [ClusterLiquidated!]!
  clusterReactivated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterReactivated
  clusterReactivateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterReactivated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterReactivated_filter
  ): [ClusterReactivated!]!
  clusterWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ClusterWithdrawn
  clusterWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ClusterWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ClusterWithdrawn_filter
  ): [ClusterWithdrawn!]!
  clusters(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Cluster_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Cluster_filter
  ): [Cluster!]!
  daovalues(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOValues
  daovalues_collection(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DAOValues_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DAOValues_filter
  ): [DAOValues!]!
  declareOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DeclareOperatorFeePeriodUpdated
  declareOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DeclareOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DeclareOperatorFeePeriodUpdated_filter
  ): [DeclareOperatorFeePeriodUpdated!]!
  executeOperatorFeePeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExecuteOperatorFeePeriodUpdated
  executeOperatorFeePeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ExecuteOperatorFeePeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ExecuteOperatorFeePeriodUpdated_filter
  ): [ExecuteOperatorFeePeriodUpdated!]!
  feeRecipientAddressUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeRecipientAddressUpdated
  feeRecipientAddressUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FeeRecipientAddressUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FeeRecipientAddressUpdated_filter
  ): [FeeRecipientAddressUpdated!]!
  liquidationThresholdPeriodUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidationThresholdPeriodUpdated
  liquidationThresholdPeriodUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidationThresholdPeriodUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidationThresholdPeriodUpdated_filter
  ): [LiquidationThresholdPeriodUpdated!]!
  minimumLiquidationCollateralUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MinimumLiquidationCollateralUpdated
  minimumLiquidationCollateralUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: MinimumLiquidationCollateralUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: MinimumLiquidationCollateralUpdated_filter
  ): [MinimumLiquidationCollateralUpdated!]!
  networkEarningsWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkEarningsWithdrawn
  networkEarningsWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkEarningsWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkEarningsWithdrawn_filter
  ): [NetworkEarningsWithdrawn!]!
  networkFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NetworkFeeUpdated
  networkFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NetworkFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NetworkFeeUpdated_filter
  ): [NetworkFeeUpdated!]!
  operator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Operator
  operatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorAdded
  operatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorAdded_filter
  ): [OperatorAdded!]!
  operatorFeeDeclarationCancelled(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclarationCancelled
  operatorFeeDeclarationCancelleds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclarationCancelled_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclarationCancelled_filter
  ): [OperatorFeeDeclarationCancelled!]!
  operatorFeeDeclared(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeDeclared
  operatorFeeDeclareds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeDeclared_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeDeclared_filter
  ): [OperatorFeeDeclared!]!
  operatorFeeExecuted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeExecuted
  operatorFeeExecuteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeExecuted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeExecuted_filter
  ): [OperatorFeeExecuted!]!
  operatorFeeIncreaseLimitUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorFeeIncreaseLimitUpdated
  operatorFeeIncreaseLimitUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorFeeIncreaseLimitUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorFeeIncreaseLimitUpdated_filter
  ): [OperatorFeeIncreaseLimitUpdated!]!
  operatorMaximumFeeUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMaximumFeeUpdated
  operatorMaximumFeeUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMaximumFeeUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMaximumFeeUpdated_filter
  ): [OperatorMaximumFeeUpdated!]!
  operatorMultipleWhitelistRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistRemoved
  operatorMultipleWhitelistRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistRemoved_filter
  ): [OperatorMultipleWhitelistRemoved!]!
  operatorMultipleWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorMultipleWhitelistUpdated
  operatorMultipleWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorMultipleWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorMultipleWhitelistUpdated_filter
  ): [OperatorMultipleWhitelistUpdated!]!
  operatorPrivacyStatusUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorPrivacyStatusUpdated
  operatorPrivacyStatusUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorPrivacyStatusUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorPrivacyStatusUpdated_filter
  ): [OperatorPrivacyStatusUpdated!]!
  operatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorRemoved
  operatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorRemoved_filter
  ): [OperatorRemoved!]!
  operatorWhitelistUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistUpdated
  operatorWhitelistUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistUpdated_filter
  ): [OperatorWhitelistUpdated!]!
  operatorWhitelistingContractUpdated(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWhitelistingContractUpdated
  operatorWhitelistingContractUpdateds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWhitelistingContractUpdated_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWhitelistingContractUpdated_filter
  ): [OperatorWhitelistingContractUpdated!]!
  operatorWithdrawn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OperatorWithdrawn
  operatorWithdrawns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OperatorWithdrawn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OperatorWithdrawn_filter
  ): [OperatorWithdrawn!]!
  operators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Operator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Operator_filter
  ): [Operator!]!
  validator(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Validator
  validatorAdded(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorAdded
  validatorAddeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorAdded_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorAdded_filter
  ): [ValidatorAdded!]!
  validatorRemoved(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ValidatorRemoved
  validatorRemoveds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ValidatorRemoved_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ValidatorRemoved_filter
  ): [ValidatorRemoved!]!
  validators(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Validator_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Validator_filter
  ): [Validator!]!
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type Validator {
  cluster: Cluster!
  id: Bytes!
  lastUpdateBlockNumber: BigInt!
  lastUpdateBlockTimestamp: BigInt!
  lastUpdateTransactionHash: Bytes!
  operators(first: Int = 100, orderBy: Operator_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Operator_filter): [Operator!]!
  owner: Account!
  removed: Boolean!
  shares: Bytes!
}

type ValidatorAdded {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  publicKey: Bytes!
  shares: Bytes!
  transactionHash: Bytes!
}

input ValidatorAdded_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ValidatorAdded_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ValidatorAdded_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  shares: Bytes
  shares_contains: Bytes
  shares_gt: Bytes
  shares_gte: Bytes
  shares_in: [Bytes!]
  shares_lt: Bytes
  shares_lte: Bytes
  shares_not: Bytes
  shares_not_contains: Bytes
  shares_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ValidatorAdded_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  publicKey
  shares
  transactionHash
}

type ValidatorRemoved {
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  cluster_active: Boolean!
  cluster_balance: BigInt!
  cluster_index: BigInt!
  cluster_networkFeeIndex: BigInt!
  cluster_validatorCount: BigInt!
  id: String!
  operatorIds: [BigInt!]!
  owner: Bytes!
  publicKey: Bytes!
  transactionHash: Bytes!
}

input ValidatorRemoved_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ValidatorRemoved_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_lt: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_not_in: [BigInt!]
  cluster_active: Boolean
  cluster_active_in: [Boolean!]
  cluster_active_not: Boolean
  cluster_active_not_in: [Boolean!]
  cluster_balance: BigInt
  cluster_balance_gt: BigInt
  cluster_balance_gte: BigInt
  cluster_balance_in: [BigInt!]
  cluster_balance_lt: BigInt
  cluster_balance_lte: BigInt
  cluster_balance_not: BigInt
  cluster_balance_not_in: [BigInt!]
  cluster_index: BigInt
  cluster_index_gt: BigInt
  cluster_index_gte: BigInt
  cluster_index_in: [BigInt!]
  cluster_index_lt: BigInt
  cluster_index_lte: BigInt
  cluster_index_not: BigInt
  cluster_index_not_in: [BigInt!]
  cluster_networkFeeIndex: BigInt
  cluster_networkFeeIndex_gt: BigInt
  cluster_networkFeeIndex_gte: BigInt
  cluster_networkFeeIndex_in: [BigInt!]
  cluster_networkFeeIndex_lt: BigInt
  cluster_networkFeeIndex_lte: BigInt
  cluster_networkFeeIndex_not: BigInt
  cluster_networkFeeIndex_not_in: [BigInt!]
  cluster_validatorCount: BigInt
  cluster_validatorCount_gt: BigInt
  cluster_validatorCount_gte: BigInt
  cluster_validatorCount_in: [BigInt!]
  cluster_validatorCount_lt: BigInt
  cluster_validatorCount_lte: BigInt
  cluster_validatorCount_not: BigInt
  cluster_validatorCount_not_in: [BigInt!]
  id: String
  id_contains: String
  id_contains_nocase: String
  id_ends_with: String
  id_ends_with_nocase: String
  id_gt: String
  id_gte: String
  id_in: [String!]
  id_lt: String
  id_lte: String
  id_not: String
  id_not_contains: String
  id_not_contains_nocase: String
  id_not_ends_with: String
  id_not_ends_with_nocase: String
  id_not_in: [String!]
  id_not_starts_with: String
  id_not_starts_with_nocase: String
  id_starts_with: String
  id_starts_with_nocase: String
  operatorIds: [BigInt!]
  operatorIds_contains: [BigInt!]
  operatorIds_contains_nocase: [BigInt!]
  operatorIds_not: [BigInt!]
  operatorIds_not_contains: [BigInt!]
  operatorIds_not_contains_nocase: [BigInt!]
  or: [ValidatorRemoved_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  publicKey: Bytes
  publicKey_contains: Bytes
  publicKey_gt: Bytes
  publicKey_gte: Bytes
  publicKey_in: [Bytes!]
  publicKey_lt: Bytes
  publicKey_lte: Bytes
  publicKey_not: Bytes
  publicKey_not_contains: Bytes
  publicKey_not_in: [Bytes!]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
}

enum ValidatorRemoved_orderBy {
  blockNumber
  blockTimestamp
  cluster_active
  cluster_balance
  cluster_index
  cluster_networkFeeIndex
  cluster_validatorCount
  id
  operatorIds
  owner
  publicKey
  transactionHash
}

input Validator_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Validator_filter]
  cluster: String
  cluster_: Cluster_filter
  cluster_contains: String
  cluster_contains_nocase: String
  cluster_ends_with: String
  cluster_ends_with_nocase: String
  cluster_gt: String
  cluster_gte: String
  cluster_in: [String!]
  cluster_lt: String
  cluster_lte: String
  cluster_not: String
  cluster_not_contains: String
  cluster_not_contains_nocase: String
  cluster_not_ends_with: String
  cluster_not_ends_with_nocase: String
  cluster_not_in: [String!]
  cluster_not_starts_with: String
  cluster_not_starts_with_nocase: String
  cluster_starts_with: String
  cluster_starts_with_nocase: String
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  lastUpdateBlockNumber: BigInt
  lastUpdateBlockNumber_gt: BigInt
  lastUpdateBlockNumber_gte: BigInt
  lastUpdateBlockNumber_in: [BigInt!]
  lastUpdateBlockNumber_lt: BigInt
  lastUpdateBlockNumber_lte: BigInt
  lastUpdateBlockNumber_not: BigInt
  lastUpdateBlockNumber_not_in: [BigInt!]
  lastUpdateBlockTimestamp: BigInt
  lastUpdateBlockTimestamp_gt: BigInt
  lastUpdateBlockTimestamp_gte: BigInt
  lastUpdateBlockTimestamp_in: [BigInt!]
  lastUpdateBlockTimestamp_lt: BigInt
  lastUpdateBlockTimestamp_lte: BigInt
  lastUpdateBlockTimestamp_not: BigInt
  lastUpdateBlockTimestamp_not_in: [BigInt!]
  lastUpdateTransactionHash: Bytes
  lastUpdateTransactionHash_contains: Bytes
  lastUpdateTransactionHash_gt: Bytes
  lastUpdateTransactionHash_gte: Bytes
  lastUpdateTransactionHash_in: [Bytes!]
  lastUpdateTransactionHash_lt: Bytes
  lastUpdateTransactionHash_lte: Bytes
  lastUpdateTransactionHash_not: Bytes
  lastUpdateTransactionHash_not_contains: Bytes
  lastUpdateTransactionHash_not_in: [Bytes!]
  operators: [String!]
  operators_: Operator_filter
  operators_contains: [String!]
  operators_contains_nocase: [String!]
  operators_not: [String!]
  operators_not_contains: [String!]
  operators_not_contains_nocase: [String!]
  or: [Validator_filter]
  owner: String
  owner_: Account_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  removed: Boolean
  removed_in: [Boolean!]
  removed_not: Boolean
  removed_not_in: [Boolean!]
  shares: Bytes
  shares_contains: Bytes
  shares_gt: Bytes
  shares_gte: Bytes
  shares_in: [Bytes!]
  shares_lt: Bytes
  shares_lte: Bytes
  shares_not: Bytes
  shares_not_contains: Bytes
  shares_not_in: [Bytes!]
}

enum Validator_orderBy {
  cluster
  cluster__active
  cluster__balance
  cluster__id
  cluster__index
  cluster__lastUpdateBlockNumber
  cluster__lastUpdateBlockTimestamp
  cluster__lastUpdateTransactionHash
  cluster__networkFeeIndex
  cluster__validatorCount
  id
  lastUpdateBlockNumber
  lastUpdateBlockTimestamp
  lastUpdateTransactionHash
  operators
  owner
  owner__feeRecipient
  owner__id
  owner__nonce
  owner__validatorCount
  removed
  shares
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """The hash of the parent block"""
  parentHash: Bytes
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}